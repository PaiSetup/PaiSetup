from steps.step import Step
from utils import command
import os
import tempfile
from utils.log import log
from enum import Enum
from pathlib import Path


class FileType(Enum):
    PosixShell = 1
    XResources = 2
    Bash = 3
    Json = 4
    ConfigFile = 5
    ConfigFileNoComments = 6
    Lua = 7
    Css = 8
    Javascript = 9
    Xml = 10
    Python = 11
    Vimrc = 12

    _properties = {
        # fmt: off
        PosixShell:           ("#",    "",    "#!/usr/bin/sh",    True),
        XResources:           ("!",    "",    None,               False),
        Bash:                 ("#",    "",    "#!/usr/bin/bash",  False),
        Json:                 (None,   "",    None,               False),
        ConfigFile:           ("#",    "",    None,               False),
        ConfigFileNoComments: (None,   "",    None,               False),
        Lua:                  ("--",   "",    None,               False),
        Css:                  ("/*",   " */", None,               False),
        Javascript:           ("//",   "",    None,               False),
        Xml:                  ("<!--", "-->", None,               False),
        Python:               ("#",    "",    "#!/bin/python",    False),
        Vimrc:                ('"',    "",    None,               False),
        # fmt: on
    }

    @classmethod
    def _get_properties(cls, file_type):
        return cls._properties.value[file_type.value]

    @classmethod
    def get_comment_prefix(cls, file_type):
        return cls._get_properties(file_type)[0]

    @classmethod
    def get_comment_suffix(cls, file_type):
        return cls._get_properties(file_type)[1]

    @classmethod
    def get_shebang(cls, file_type):
        return cls._get_properties(file_type)[2]

    @classmethod
    def is_executable(cls, file_type):
        return cls._get_properties(file_type)[3]


class InvalidFileTypeUsageException(Exception):
    pass


class ChangedFileTypeException(Exception):
    pass


class ParseFailureException(Exception):
    pass


class LinePlacement(Enum):
    Normal = 1
    End = 2


class FileDesc:
    def __init__(self, path, file_type):
        self.path = path
        self.preamble_written = False
        self.file_type = file_type
        self.end_lines = []


class FileWriter(Step):
    def __init__(self):
        self._files = dict()

    @staticmethod
    def resolve_path(path):
        path = Path(path)
        if path.is_absolute():
            return path
        else:
            return Step._env.home() / path

    def _ensure_file_is_deleted(self, path):
        Path(path).parent.mkdir(parents=True, exist_ok=True)
        self.remove_file(path)

    def finalize(self):
        for file_desc in self._files.values():
            if file_desc.end_lines:
                self.write_lines(
                    file_desc.path,
                    file_desc.end_lines,
                    file_type=file_desc.file_type,
                    line_placement=LinePlacement.Normal,
                )

    def write_lines(
        self,
        path,
        lines,
        *,
        file_type=FileType.PosixShell,
        line_placement=LinePlacement.Normal,
    ):
        path = FileWriter.resolve_path(path)

        # Get description of the file
        if path in self._files:
            file_desc = self._files[path]
            is_first_access = False
        else:
            file_desc = FileDesc(path, file_type)
            self._files[path] = file_desc
            is_first_access = True

        # Validate if file type changed
        if file_type != file_desc.file_type:
            raise ChangedFileTypeException()

        # Requests with LinePlacement.End will be processed later
        if line_placement == LinePlacement.End:
            file_desc.end_lines += lines
            return

        # If we're seeing this file for the first time
        if not file_desc.preamble_written:
            file_desc.preamble_written = True

            # Ensure directory is created and the file is empty
            self._ensure_file_is_deleted(path)

            # Insert initial comments, if the filetype supports them
            prefix = FileType.get_comment_prefix(file_type)
            suffix = FileType.get_comment_suffix(file_type)
            if prefix:
                init_lines = []

                # Add shebang
                shebang = FileType.get_shebang(file_type)
                if shebang:
                    init_lines.append(shebang)
                    init_lines.append(prefix)

                # Add initial warning comment
                init_lines += [
                    f"{prefix} This file has been autogenerated by PaiSetup.{suffix}",
                    f"{prefix} Do not change it manually{suffix}",
                    f"{prefix}{suffix}",
                    f"",
                ]

                lines = init_lines + lines

        # Write lines to the end of the file
        lines = "\n".join(lines + [""])
        try:
            with open(path, "a") as file:
                file.writelines(lines)
        except PermissionError:
            command.run_command(f'echo "{lines}" | sudo tee {path} >/dev/null', shell=True)

        # Setup permissions if this is the first time we touch this file
        if is_first_access and FileType.is_executable(file_type):
            command.run_command(f"sudo chmod +x {path}")

        # Return resolved path
        return path

    def write_section(self, path, section_comment, lines, *, file_type=FileType.PosixShell, **kwargs):
        prefix = FileType.get_comment_prefix(file_type)
        suffix = FileType.get_comment_suffix(file_type)
        if not prefix:
            raise InvalidFileTypeUsageException(f"Filetype {file_type.name} does not allow comments")

        lines = [f"{prefix} {section_comment}{suffix}"] + lines + [""]
        return self.write_lines(path, lines, file_type=file_type, **kwargs)

    def write_symlink(
        self,
        src,
        link,
        **kwargs,
    ):
        src = FileWriter.resolve_path(src)
        link = FileWriter.resolve_path(link)
        self._ensure_file_is_deleted(link)
        os.symlink(src, link)
        return link

    def write_executable_script(self, file_name, lines):
        path = Path("/usr/local/bin") / file_name

        return self.write_lines(path, lines, file_type=FileType.PosixShell)

    def remove_file(self, path):
        path = FileWriter.resolve_path(path)
        try:
            os.remove(path)
        except FileNotFoundError:
            pass
        except PermissionError:
            command.run_command(f"sudo rm {path}")

    def patch_dot_desktop_file(self, source_name, destination_name, patch_functions):
        """
        Takes .desktop file from /usr/share/applications, applies patch functions to its
        contents and creates a new file in a user specific folder for .desktop files.

        Each line is matched to a zero or one patch function. Contents of a matched line is
        passed to the patch function, which returns a new value for the current line.

        Parameters:
            source_name - name of file in /usr/share/applications with .deskop suffix
            destination_name - name of file in ~/.local/share/applications with .deskop suffix
            patch_functions - a dictionary
                keys are names of values in .desktop file (e.g. "Exec")
                values are functions taking a section, base name (without square bracket modifiers) and value and returning a new value
        """
        source_file_path = f"/usr/share/applications/{source_name}"
        destination_file_path = Step._env.home() / ".local/share/applications" / destination_name

        lines = []
        with open(source_file_path, "r") as src:
            section = ""
            for untrimmed_line in src:
                line = untrimmed_line.strip()
                modified_line = untrimmed_line[:-1] # Remove the newline

                if line.startswith("#"):
                    pass
                elif line.startswith("["):
                    section = line[1:-1]
                else:
                    # line is e.g. "Name[de]=Vim"
                    line_name = line.split("=")[0]  # e.g. "Name[de]"
                    line_base_name = line_name.split("[")[0]  # e.g. "Name"
                    line_value = "=".join(line.split("=")[1:])  # e.g. "Vim"

                    if line_base_name in patch_functions:
                        patch_function = patch_functions[line_base_name]
                        modified_line_value = patch_function(section, line_name, line_value)
                        modified_line = f"{line_name}={modified_line_value}"

                lines.append(modified_line)
        self.write_lines(destination_file_path, lines, file_type=FileType.ConfigFile)

    def patch_ini_file(self, file_path, patch_functions):
        """
        Parses an .ini file, applies patch functions to its contents and saves it back to disc.

        Each line is matched to a zero or one patch function. Contents of a matched line is
        passed to the patch function, which returns a new value for the current line. The patch
        function is matched by section name and key name.

        Parameters:
            file_path - patch to the .ini file
            patch_functions - a dictionary
                keys are tuples of section name and key name used for matching the patch function, e.g. ("GraphicsSettings", "Resolution")
                values are functions taking a current value and returning a new value
        """

        file_path = FileWriter.resolve_path(file_path)
        with open(file_path, "r") as real_file:
            with tempfile.NamedTemporaryFile(mode='w', delete=False, prefix=f"{file_path}.tmp_") as tmp_file:
                section = ""
                for line in real_file:
                    line = line[:-1] # Remove the newline
                    line_content, line_comment = FileWriter._split_comment(line)

                    # Find out type of current line
                    if not line_content: # Empty line
                        pass
                    elif line_content.startswith('[') and line_content.endswith(']'): # Section line
                        section = line_content[1:-1]
                    elif assignement := FileWriter._split_assignment(line_content): # Key-value pair line
                        key, assignement, value = assignement

                        # Apply a patch function if it matches
                        try:
                            patch_function = patch_functions[(section, key)]
                            value = patch_function(value)
                            line_content = f"{key}{assignement}{value}"
                        except KeyError:
                            pass
                    else:
                        raise ParseFailureException("Unknown line type")

                    tmp_file.write(f"{line_content}{line_comment}\n")

        os.rename(tmp_file.name, str(file_path))

    @staticmethod
    def _split_comment(line, comment_signs=['#']):
        comment_start = [line.find(comment_sign) for comment_sign in comment_signs]
        comment_start = min(comment_start)
        if comment_start == -1:
            return (line, "")

        while comment_start > 0 and line[comment_start - 1] == ' ':
            comment_start -= 1

        return (
            line[:comment_start],
            line[comment_start:],
        )


    @staticmethod
    def _split_assignment(line):
        assignment_sign_start = line.find("=")
        assignment_sign_end = assignment_sign_start
        if assignment_sign_start == -1:
            return None

        while assignment_sign_start > 0 and line[assignment_sign_start - 1] == ' ':
            assignment_sign_start -= 1
        while assignment_sign_end < len(line) - 2 and line[assignment_sign_end + 1] == ' ':
            assignment_sign_end += 1

        key = line[:assignment_sign_start]
        assignement = line[assignment_sign_start:assignment_sign_end+1]
        value = line[assignment_sign_end + 1:]

        if '=' in key or '=' in value:
            return None

        return key, assignement, value
