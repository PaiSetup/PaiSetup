from steps.step import Step
from utils import command
import os
from utils.log import log
from enum import Enum
from pathlib import Path


class FileType(Enum):
    PosixShell = 1
    XResources = 2
    Bash = 3
    Json = 4
    ConfigFile = 5
    Lua = 6
    Css = 7

    _properties = {
        # fmt: off
        PosixShell: ("#",    "",    "#!/usr/bin/sh",    True),
        XResources: ("!",    "",    None,               False),
        Bash:       ("#",    "",    "#!/usr/bin/bash",  False),
        Json:       (None,   "",    None,               False),
        ConfigFile: ("#",    "",    None,               False),
        Lua:        ("--",   "",    None,               False),
        Css:        ("/*",   " */", None,               False),
        # fmt: on
    }

    @classmethod
    def _get_properties(cls, file_type):
        return cls._properties.value[file_type.value]

    @classmethod
    def get_comment_prefix(cls, file_type):
        return cls._get_properties(file_type)[0]

    @classmethod
    def get_comment_suffix(cls, file_type):
        return cls._get_properties(file_type)[1]

    @classmethod
    def get_shebang(cls, file_type):
        return cls._get_properties(file_type)[2]

    @classmethod
    def is_executable(cls, file_type):
        return cls._get_properties(file_type)[3]


class InvalidFileTypeUsageException(Exception):
    pass


class ChangedFileTypeException(Exception):
    pass


class LinePlacement(Enum):
    Normal = 1
    End = 2


class FileDesc:
    def __init__(self, path, file_type):
        self.path = path
        self.preamble_written = False
        self.file_type = file_type
        self.end_lines = []


class FileWriter(Step):
    def __init__(self):
        self._files = dict()

    @staticmethod
    def resolve_path(path):
        path = Path(path)
        if path.is_absolute():
            return path
        else:
            return Step._env.home() / path

    def _ensure_file_is_deleted(self, path):
        Path(path).parent.mkdir(parents=True, exist_ok=True)
        self.remove_file(path)

    def finalize(self):
        for file_desc in self._files.values():
            if file_desc.end_lines:
                self.write_lines(
                    file_desc.path,
                    file_desc.end_lines,
                    file_type=file_desc.file_type,
                    line_placement=LinePlacement.Normal,
                )

    def write_lines(
        self,
        path,
        lines,
        *,
        file_type=FileType.PosixShell,
        line_placement=LinePlacement.Normal,
    ):
        path = FileWriter.resolve_path(path)

        # Get description of the file
        if path in self._files:
            file_desc = self._files[path]
            is_first_access = False
        else:
            file_desc = FileDesc(path, file_type)
            self._files[path] = file_desc
            is_first_access = True

        # Validate if file type changed
        if file_type != file_desc.file_type:
            raise ChangedFileTypeException()

        # Requests with LinePlacement.End will be processed later
        if line_placement == LinePlacement.End:
            file_desc.end_lines += lines
            return

        # If we're seeing this file for the first time
        if not file_desc.preamble_written:
            file_desc.preamble_written = True

            # Ensure directory is created and the file is empty
            self._ensure_file_is_deleted(path)

            # Insert initial comments, if the filetype supports them
            prefix = FileType.get_comment_prefix(file_type)
            suffix = FileType.get_comment_suffix(file_type)
            if prefix:
                init_lines = []

                # Add shebang
                shebang = FileType.get_shebang(file_type)
                if shebang:
                    init_lines.append(shebang)
                    init_lines.append(prefix)

                # Add initial warning comment
                init_lines += [
                    f"{prefix} This file has been autogenerated by LinuxSetup.{suffix}",
                    f"{prefix} Do not change it manually{suffix}",
                    f"{prefix}{suffix}",
                    f"",
                ]

                lines = init_lines + lines

        # Write lines to the end of the file
        lines = "\n".join(lines + [""])
        try:
            with open(path, "a") as file:
                file.writelines(lines)
        except PermissionError:
            command.run_command(f'echo "{lines}" | sudo tee {path} >/dev/null', shell=True)

        # Setup permissions if this is the first time we touch this file
        if is_first_access and FileType.is_executable(file_type):
            command.run_command(f"sudo chmod +x {path}")

        # Return resolved path
        return path

    def write_section(self, path, section_comment, lines, *, file_type=FileType.PosixShell, **kwargs):
        prefix = FileType.get_comment_prefix(file_type)
        suffix = FileType.get_comment_suffix(file_type)
        if not prefix:
            raise InvalidFileTypeUsageException(f"Filetype {file_type.name} does not allow comments")

        lines = [f"{prefix} {section_comment}{suffix}"] + lines + [""]
        return self.write_lines(path, lines, file_type=file_type, **kwargs)

    def write_symlink(
        self,
        src,
        link,
        **kwargs,
    ):
        src = FileWriter.resolve_path(src)
        link = FileWriter.resolve_path(link)
        self._ensure_file_is_deleted(link)
        os.symlink(src, link)
        return link

    def write_executable_script(self, file_name, lines):
        path = Path("/usr/local/bin") / file_name

        return self.write_lines(path, lines, file_type=FileType.PosixShell)

    def remove_file(self, path):
        path = FileWriter.resolve_path(path)
        try:
            os.remove(path)
        except FileNotFoundError:
            pass
        except PermissionError:
            command.run_command(f"sudo rm {path}")

    def patch_dot_desktop_file(self, source_name, destination_name, patch_functions):
        """
        Takes .desktop file from /usr/share/applications, applies patch functions to its
        contents and creates a new file in a user specific folder for .desktop files.

        Each line is matched to a zero or one patch function. Contents of a matched line is
        pass to the patch function, which returns a new value for the current line.

        Parameters:
            source_name - name of file in /usr/share/applications with .deskop suffix
            destination_name - name of file in ~/.local/share/applications with .deskop suffix
            patch_functions - a dictionary
                keys are names of values in .desktop file (e.g. "Exec")
                values are functions taking a section, base name (without square bracket modifiers) and value and returning a new value
        """
        source_file_path = f"/usr/share/applications/{source_name}"
        destination_file_path = Step._env.home() / ".local/share/applications" / destination_name

        lines = []
        with open(source_file_path, "r") as src:
            section = ""
            for untrimmed_line in src:
                line = untrimmed_line.strip()
                modified_line = untrimmed_line[:-1] # Remove the newline

                if line.startswith("#"):
                    pass
                elif line.startswith("["):
                    section = line[1:-1]
                else:
                    # line is e.g. "Name[de]=Vim"
                    line_name = line.split("=")[0]  # e.g. "Name[de]"
                    line_base_name = line_name.split("[")[0]  # e.g. "Name"
                    line_value = "=".join(line.split("=")[1:])  # e.g. "Vim"

                    if line_base_name in patch_functions:
                        patch_function = patch_functions[line_base_name]
                        modified_line_value = patch_function(section, line_name, line_value)
                        modified_line = f"{line_name}={modified_line_value}"

                lines.append(modified_line)
        self.write_lines(destination_file_path, lines, file_type=FileType.ConfigFile)
